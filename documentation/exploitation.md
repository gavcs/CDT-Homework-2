# Exploitation Documentation

### NOTE: This is a very vulnerable flag. I developed this in mind with the difficulty of the other flags created by Foxtrot. The goal wasn't to necessarily develop something very difficult to find, but to balance the competition by having flags that people of varying skill levels can find. It shouldn't be impossible for Red Team to win just as much as it shouldn't be too easy to find all flags.

## 1. Vulnerability Overview

### Vulnerability Info
&emsp;This service logs message insecurely. The idea is that companies have chat services such as slack or teams to communicate with one another. In this case the company chat was done through IRC to mimic slack or teams. If red team can gain access to a priviledged user, it would allow them to login to the server that the IRC chat is located. This would mean that all files on that server are also accessible to red team through that user. That's what makes logging every message to /var/log/ircd/messages.log so dangerous.
&emsp;The way an attacker would find this is by finding the systemd service that's running the python script, check the python script, and then find the messages.log location. They can then check that location to find the flag.
### Severity & Impact
&emsp;The severity and impact of this vulnerable service varies significantly. On one had, the chats may not contain anything of use, but on the other, companies use services like this often to allow employees to communicate about technical things privately. This means that ip addresses, users, domains, and plenty of other useful information would be contained in something like this. It would make the server a place to find areas of value to the attacker.

## 2. Exploitation Steps

### Steps to find the Vulnerable Logs
REMINDER: The message logs are vulnerable only when a user is able to gain access to the domain in the first place. This means that it would aid in assisting the attacker to move laterally around blue team's infrastructure and to gain more information on the layout of the infrastructure as a whole, user accounts to try password cracking (kerberoasting would be helpful in this case), ip addresses, and potentially would be able to find the usernames of many administrator accounts.
```bash
cyberrange@gwm8432-serv-3:~$ systemctl list-units --type=service
  UNIT                               LOAD   ACTIVE SUB     DESCRIPTION                                                                  
  accounts-daemon.service            loaded active running Accounts Service
  acpid.service                      loaded active running ACPI event daemon
  apparmor.service                   loaded active exited  Load AppArmor profiles
  apport.service                     loaded active exited  LSB: automatic crash report generation
  avahi-daemon.service               loaded active running Avahi mDNS/DNS-SD Stack
  blk-availability.service           loaded active exited  Availability of block devices
  cloud-config.service               loaded active exited  Cloud-init: Config Stage
  cloud-final.service                loaded active exited  Cloud-init: Final Stage
  cloud-init-local.service           loaded active exited  Cloud-init: Local Stage (pre-network)
  cloud-init.service                 loaded active exited  Cloud-init: Network Stage
  console-setup.service              loaded active exited  Set console font and keymap
  cron.service                       loaded active running Regular background program processing daemon
  cups-browsed.service               loaded active running Make remote CUPS printers available locally
  cups.service                       loaded active running CUPS Scheduler
  dbus.service                       loaded active running D-Bus System Message Bus
  haveged.service                    loaded active running Entropy Daemon based on the HAVEGE algorithm
  inspircd.service                   loaded active running InspIRCd - Internet Relay Chat Daemon
  irc-logger.service                 loaded active running IRC Message Logger
  kerneloops.service                 loaded active running Tool to automatically collect and submit kernel crash signatures
  keyboard-setup.service             loaded active exited  Set the console keyboard layout
  kmod-static-nodes.service          loaded active exited  Create List of Static Device Nodes
  lvm2-monitor.service               loaded active exited  Monitoring of LVM2 mirrors, snapshots etc. using dmeventd or progress polling
  ModemManager.service               loaded active running Modem Manager
  networkd-dispatcher.service        loaded active running Dispatcher daemon for systemd-networkd
  NetworkManager-wait-online.service loaded active exited  Network Manager Wait Online
  NetworkManager.service             loaded active running Network Manager
  packagekit.service                 loaded active running PackageKit Daemon
  plymouth-quit.service              loaded active exited  Terminate Plymouth Boot Screen
  plymouth-read-write.service        loaded active exited  Tell Plymouth To Write Out Runtime Data
  plymouth-start.service             loaded active exited  Show Plymouth Boot Screen
  polkit.service                     loaded active running Authorization Manager
  qemu-guest-agent.service           loaded active running QEMU Guest Agent
  rsyslog.service                    loaded active running System Logging Service
  rtkit-daemon.service               loaded active running RealtimeKit Scheduling Policy Service
  sddm.service                       loaded active running Simple Desktop Display Manager
  setvtrgb.service                   loaded active exited  Set console scheme
  snapd.apparmor.service             loaded active exited  Load AppArmor profiles managed internally by snapd
  snapd.seeded.service               loaded active exited  Wait until snapd is fully seeded
  snapd.service                      loaded active running Snap Daemon
  ssh.service                        loaded active running OpenBSD Secure Shell server
  systemd-binfmt.service             loaded active exited  Set Up Additional Binary Formats
  systemd-journal-flush.service      loaded active exited  Flush Journal to Persistent Storage
  systemd-journald.service           loaded active running Journal Service
  systemd-logind.service             loaded active running User Login Management
  systemd-machine-id-commit.service  loaded active exited  Commit a transient machine-id on disk
  systemd-modules-load.service       loaded active exited  Load Kernel Modules
  systemd-random-seed.service        loaded active exited  Load/Save Random Seed
  systemd-remount-fs.service         loaded active exited  Remount Root and Kernel File Systems
  systemd-resolved.service           loaded active running Network Name Resolution
  systemd-sysctl.service             loaded active exited  Apply Kernel Variables
  systemd-sysusers.service           loaded active exited  Create System Users
  systemd-timesyncd.service          loaded active running Network Time Synchronization
  systemd-tmpfiles-setup-dev.service loaded active exited  Create Static Device Nodes in /dev
  systemd-tmpfiles-setup.service     loaded active exited  Create Volatile Files and Directories
  systemd-udev-trigger.service       loaded active exited  Coldplug All udev Devices
  systemd-udevd.service              loaded active running Rule-based Manager for Device Events and Files
  systemd-update-utmp.service        loaded active exited  Record System Boot/Shutdown in UTMP
  systemd-user-sessions.service      loaded active exited  Permit User Sessions
  udisks2.service                    loaded active running Disk Manager
  ufw.service                        loaded active exited  Uncomplicated firewall
  unattended-upgrades.service        loaded active running Unattended Upgrades Shutdown
  upower.service                     loaded active running Daemon for power management
  user-runtime-dir@1000.service      loaded active exited  User Runtime Directory /run/user/1000
  user@1000.service                  loaded active running User Manager for UID 1000
  wpa_supplicant.service             loaded active running WPA supplicant

LOAD   = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB    = The low-level unit activation state, values depend on unit type.
65 loaded units listed. Pass --all to see loaded but inactive units, too.
To show all installed unit files use 'systemctl list-unit-files'.
cyberrange@gwm8432-serv-3:~$ systemctl cat irc-logger
# /etc/systemd/system/irc-logger.service
[Unit]
Description=IRC Message Logger
After=inspircd.service
Requires=inspircd.service

[Service]
Type=simple
ExecStart=/usr/bin/python3 /usr/local/bin/irc-logger.py
Restart=always
User=irc

[Install]
WantedBy=multi-user.target
```

### Exploitation
Cat the python file to see what it's doing and where the irc-logger.service is logging to
``` python
# (bash command entered to receive this file) cyberrange@gwm8432-serv-3:~$ cat /usr/local/bin/irc-logger.py 
#!/usr/bin/env python3
import socket
import time
from datetime import datetime

SERVER = "127.0.0.1"
PORT = 6667
PASSWORD = "cyberpsychosis"
NICKNAME = "logger"
CHANNEL = "#general"
LOGFILE = "/var/log/ircd/messages.log"

def log_message(msg):
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    with open(LOGFILE, 'a') as f:
        f.write(f"{timestamp} {msg}\n")

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((SERVER, PORT))

sock.send(f"PASS {PASSWORD}\r\n".encode())
sock.send(f"NICK {NICKNAME}\r\n".encode())
sock.send(f"USER {NICKNAME} 0 * :Logger Bot\r\n".encode())

time.sleep(2)
sock.send(f"JOIN {CHANNEL}\r\n".encode())

while True:
    try:
        data = sock.recv(4096).decode('utf-8', errors='ignore')
        if not data:
            break

        for line in data.split('\r\n'):
            if line:
                log_message(line)

                # Handle PING
                if line.startswith('PING'):
                    sock.send(f"PONG {line.split()[1]}\r\n".encode())

                # Log channel messages
                if 'PRIVMSG' in line and CHANNEL in line:
                    log_message(line)
    except:
        break

sock.close()
```

Cat the log file. Adding grep flag makes it less wordy for this documentation, but shows that the flag is inside the log file.
``` bash
cyberrange@gwm8432-serv-3:~$ cat /var/log/ircd/messages.log | grep flag
2026-02-20 13:16:03 :alice!alice@100.65.6.56 PRIVMSG #general :By the way, I stored my notes in a secure place: flag{1RC_L0GS_4R3_N0T_S3CUR3}
```

### Post Exploitation
The purpose of this is reconnaissance for an attacker. As explained earlier, it would be very easy to use the information from all of the chats that employees have ever sent in the company chat to exploit further services. This would also be a great place to find admin user accounts to attempt to gain access to. This is more of a skeleton of a vulnerable service that red team can leverage to gain a further hold on blue team. Going further into the details and making this significantly more useful to red team would require more than what is in the scope of this assignment as ansible was very new to me when I started this out and I've already spent more than the suggested hours on this assignment.

## 3. Defensive Considerations

### Detection
Blue team would need to find this the same way that red team finds it. They would already be aware that logs are not securely stored just as red team is, so they'd need to find how they're stored, and then do it more securely. A good way of doing this is by doing it on another machine (isolated from the same environment, maybe one red would not check such as a random workstation for the scope of this competition). The file permissions make it so everyone can read it on that device as well.

For blue team to know if red team is attempting to exploit this vulnerability, they would want to make sure to actively monitor logged in users and user security in general. In a real environment, they'd want to keep message logger for logistical reasons, but in this competition it would be fine if they were to remove the bot logging the file as well as the service as a "pause" on the logging server side it would be fine. This would make it slightly more difficult for red team to find the logs.

### Mitigation
The best practice in this case would be logging messages to a secure database. This would make it more difficult for attackers to gain access to it. By either making the logs password authenticated for viewing (and ip restricted to write to), it would make it much more difficult to gain access to the logs. This would require the user to delete the log files, which would be deleting the flag. They'd also need to setup an entire database. Lighter mitigations would include removing the logger bot & systemd service and changing the permissions of the log files.